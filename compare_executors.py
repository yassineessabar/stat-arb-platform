#!/usr/bin/env python3
"""
Executor Comparison Script
=========================

This script compares the signals generated by:
1. simple_working_executor.py (basic mean reversion)
2. backtest_aligned_executor.py (exact backtest logic)

Use this to verify the aligned executor produces more sophisticated signals.
"""

import sys
import json
import pandas as pd
import numpy as np
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

def test_simple_executor():
    """Test signal generation from simple executor"""
    print("=" * 60)
    print("TESTING SIMPLE EXECUTOR (Mean Reversion)")
    print("=" * 60)

    # Load config
    with open('strategy_config.json', 'r') as f:
        config = json.load(f)

    # Simulate price data
    np.random.seed(42)  # For reproducible results
    prices = np.cumsum(np.random.randn(20)) + 100  # Random walk starting at 100

    print(f"Sample prices: {prices[-5:]}")

    # Calculate z-score (simple executor method)
    lookback = config.get('lookback_period', 5)
    if len(prices) >= lookback:
        mean_price = np.mean(prices[-lookback:])
        std_price = np.std(prices[-lookback:])

        if std_price > 0:
            zscore = (prices[-1] - mean_price) / std_price
        else:
            zscore = 0
    else:
        zscore = 0

    # Simple executor signals
    signal = 'HOLD'
    entry_threshold = config.get('entry_threshold', 1.0)

    if zscore < -entry_threshold:
        signal = 'BUY'
    elif zscore > entry_threshold:
        signal = 'SELL'

    print(f"Z-Score: {zscore:.3f}")
    print(f"Signal: {signal}")
    print(f"Logic: Basic mean reversion on individual asset")

    return {'zscore': zscore, 'signal': signal, 'type': 'individual_asset_mean_reversion'}

def test_backtest_aligned_executor():
    """Test signal generation from backtest-aligned executor"""
    print("\n" + "=" * 60)
    print("TESTING BACKTEST-ALIGNED EXECUTOR (Pair Trading)")
    print("=" * 60)

    try:
        from core.strategy_engine import StatArbStrategyEngine

        # Initialize strategy engine
        config_dir = Path(__file__).parent / "config"
        engine = StatArbStrategyEngine(config_dir)

        print(f"‚úÖ Strategy engine loaded")
        print(f"Parameters: z_entry={engine.params['signals']['z_entry']}")
        print(f"Parameters: z_exit_long={engine.params['signals']['z_exit_long']}")

        # Create mock price data for multiple assets
        np.random.seed(42)
        dates = pd.date_range('2024-01-01', periods=50, freq='D')

        # Create correlated price series (for cointegration)
        assets = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT']
        base_prices = np.cumsum(np.random.randn(50)) + 100

        price_data = pd.DataFrame(index=dates)
        for i, asset in enumerate(assets):
            # Add some correlation + noise
            noise = np.random.randn(50) * 0.1
            price_data[asset] = base_prices + noise + (i * 5)  # Slight offset

        print(f"Mock price data shape: {price_data.shape}")
        print(f"Last prices:\n{price_data.tail(3)}")

        # Try universe analysis
        print("\nüîç Running universe analysis...")
        universe_analysis = engine.analyze_universe(price_data)

        selected_pairs = universe_analysis.get('selected_pairs', [])
        print(f"Found {len(selected_pairs)} pairs")

        if selected_pairs:
            # Initialize pairs
            engine.initialize_pairs(selected_pairs, price_data)

            # Generate signals
            print("\nüìä Generating signals...")
            signals_result = engine.generate_signals(price_data)
            pair_signals = signals_result.get('pair_signals', {})

            print(f"Generated signals for {len(pair_signals)} pairs")

            for pair_name, signal_series in list(pair_signals.items())[:3]:  # Show first 3
                if isinstance(signal_series, pd.Series) and not signal_series.empty:
                    latest_signal = signal_series.iloc[-1]
                    print(f"  {pair_name}: {latest_signal:.3f}")

            return {
                'pairs_found': len(selected_pairs),
                'signals_generated': len(pair_signals),
                'type': 'pair_trading_with_kalman_filters',
                'sample_signals': {k: v.iloc[-1] if isinstance(v, pd.Series) and not v.empty else 0
                                 for k, v in list(pair_signals.items())[:3]}
            }
        else:
            print("‚ùå No viable pairs found in mock data")
            return {'pairs_found': 0, 'type': 'pair_trading_with_kalman_filters'}

    except Exception as e:
        print(f"‚ùå Error testing backtest executor: {e}")
        import traceback
        traceback.print_exc()
        return {'error': str(e), 'type': 'pair_trading_with_kalman_filters'}

def main():
    """Compare both executors"""
    print("STRATEGY EXECUTOR COMPARISON")
    print("Comparing signal generation approaches...\n")

    # Test simple executor
    simple_result = test_simple_executor()

    # Test backtest-aligned executor
    aligned_result = test_backtest_aligned_executor()

    # Summary
    print("\n" + "=" * 60)
    print("COMPARISON SUMMARY")
    print("=" * 60)

    print("\n1. SIMPLE EXECUTOR:")
    print(f"   - Type: {simple_result['type']}")
    print(f"   - Signal: {simple_result.get('signal', 'N/A')}")
    print(f"   - Z-Score: {simple_result.get('zscore', 'N/A')}")

    print("\n2. BACKTEST-ALIGNED EXECUTOR:")
    print(f"   - Type: {aligned_result['type']}")
    print(f"   - Pairs Found: {aligned_result.get('pairs_found', 'N/A')}")
    print(f"   - Signals Generated: {aligned_result.get('signals_generated', 'N/A')}")

    if 'sample_signals' in aligned_result:
        print("   - Sample Signals:")
        for pair, signal in aligned_result['sample_signals'].items():
            print(f"     {pair}: {signal:.3f}")

    print("\nüìä CONCLUSION:")
    print("   Simple executor uses basic mean reversion on individual assets")
    print("   Backtest-aligned executor uses sophisticated pair trading with:")
    print("   - Cointegration analysis")
    print("   - Kalman filter hedge ratios")
    print("   - Regime detection")
    print("   - Multi-tier pair quality system")
    print("   - Z-score calculations on spreads (not individual prices)")

    print(f"\n‚úÖ To get identical signals to backtest, use backtest_aligned_executor.py")

if __name__ == "__main__":
    main()