name: Statistical Arbitrage Strategy Executor (24/7)

on:
  # Manual trigger with parameters
  workflow_dispatch:
    inputs:
      trading_mode:
        description: 'Trading Mode'
        required: true
        default: 'paper'
        type: choice
        options:
          - paper
          - live
      rebalance_frequency:
        description: 'Rebalance Frequency (minutes)'
        required: false
        default: '5'
      portfolio_value:
        description: 'Portfolio Value (USDT)'
        required: false
        default: '10000'

  # Scheduled execution disabled - GitHub Actions blocked by Binance
  # schedule:
  #   - cron: '*/5 * * * *'  # Every 5 minutes, 24/7

  # Also run on push to main for updates
  push:
    branches: [ main ]
    paths:
      - 'core/**'
      - 'config/**'
      - 'dashboard/strategy_executor.py'

env:
  PYTHON_VERSION: '3.10'
  NODE_VERSION: '18'
  TZ: 'UTC'

jobs:
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}

    steps:
      - name: Check if strategy should run
        id: check
        run: |
          # Check if we're in maintenance window (optional)
          HOUR=$(date +%H)
          DAY=$(date +%u)

          # Example: Skip during maintenance (Sunday 2-4 AM UTC)
          if [ "$DAY" -eq 7 ] && [ "$HOUR" -ge 2 ] && [ "$HOUR" -lt 4 ]; then
            echo "should_run=false" >> $GITHUB_OUTPUT
            echo "â¸ï¸ Maintenance window - skipping execution"
          else
            echo "should_run=true" >> $GITHUB_OUTPUT
            echo "âœ… Ready to execute strategy"
          fi

  execute-strategy:
    name: Execute V6 Strategy
    needs: health-check
    if: needs.health-check.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    continue-on-error: true  # Allow workflow to continue even if strategy fails

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install Python Dependencies
        run: |
          pip install --upgrade pip
          pip install -r dashboard/requirements.txt

      - name: Create Configuration
        env:
          BINANCE_API_KEY: ${{ secrets.BINANCE_API_KEY }}
          BINANCE_API_SECRET: ${{ secrets.BINANCE_API_SECRET }}
          BINANCE_TESTNET_KEY: ${{ secrets.BINANCE_TESTNET_KEY }}
          BINANCE_TESTNET_SECRET: ${{ secrets.BINANCE_TESTNET_SECRET }}
          SUPABASE_URL: ${{ secrets.SUPABASE_URL || '' }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY || '' }}
        run: |
          # Check if secrets are configured
          if [ -z "${BINANCE_TESTNET_KEY}" ]; then
            echo "âš ï¸ WARNING: No API keys configured. Please add the following secrets:"
            echo "  - BINANCE_TESTNET_KEY"
            echo "  - BINANCE_TESTNET_SECRET"
            echo "  - SUPABASE_URL (optional)"
            echo "  - SUPABASE_SERVICE_KEY (optional)"
            echo ""
            echo "Using demo mode for testing..."
            API_KEY="demo_key"
            API_SECRET="demo_secret"
            TESTNET="true"
          else
            # Determine which API keys to use
            if [ "${{ github.event.inputs.trading_mode || 'paper' }}" == "live" ]; then
              API_KEY="${BINANCE_API_KEY}"
              API_SECRET="${BINANCE_API_SECRET}"
              TESTNET="false"
            else
              API_KEY="${BINANCE_TESTNET_KEY}"
              API_SECRET="${BINANCE_TESTNET_SECRET}"
              TESTNET="true"
            fi
          fi

          # Create strategy configuration
          cat > strategy_config.json << EOF
          {
            "strategy_name": "StatArb_v6_GitHub",
            "trading_mode": "${{ github.event.inputs.trading_mode || 'paper' }}",
            "universe": [
              "BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT", "XRPUSDT",
              "ADAUSDT", "AVAXUSDT", "DOGEUSDT", "DOTUSDT", "MATICUSDT",
              "LINKUSDT", "LTCUSDT", "BCHUSDT", "ETCUSDT", "XLMUSDT"
            ],
            "portfolio_value": ${{ github.event.inputs.portfolio_value || 10000 }},
            "rebalance_frequency": ${{ github.event.inputs.rebalance_frequency || 5 }},
            "deployment_id": "github_${{ github.run_id }}_${{ github.run_number }}",
            "api_key": "${API_KEY}",
            "api_secret": "${API_SECRET}",
            "testnet": ${TESTNET}
          }
          EOF

          echo "âœ… Configuration created for ${{ github.event.inputs.trading_mode || 'paper' }} trading"

      - name: Check API Access
        run: |
          # Check if we can access Binance from this location
          echo "ðŸŒ Testing API access from GitHub Actions..."
          curl -s "https://api.binance.com/api/v3/ping" || echo "âŒ Binance not accessible from this location"
          curl -s "https://testnet.binance.vision/api/v3/ping" || echo "âŒ Testnet not accessible from this location"
          echo "GitHub Actions runs from US servers where Binance is blocked."
          echo "For 24/7 trading, deploy to a VPS in a supported country."

      - name: Run Strategy for One Cycle
        timeout-minutes: 10  # Prevent infinite runs
        if: false  # Disabled due to geo-restrictions
        run: |
          # Run the strategy for one rebalance cycle
          python3 << 'PYTHON_SCRIPT'
          import sys
          import json
          import asyncio
          from pathlib import Path

          # Add paths
          sys.path.insert(0, 'dashboard')
          sys.path.insert(0, '.')

          # Import strategy executor
          from strategy_executor import V6StrategyExecutor

          # Load config
          with open('strategy_config.json', 'r') as f:
              config = json.load(f)

          # Create executor
          executor = V6StrategyExecutor('strategy_config.json')

          async def run_single_cycle():
              """Run a single strategy cycle for GitHub Actions"""
              print("ðŸš€ Starting single cycle execution...")

              # Fetch initial price data (minimal for GitHub Actions)
              for i in range(5):
                  executor.fetch_price_data()
                  await asyncio.sleep(1)

              # Run one strategy cycle
              executor.run_strategy_cycle()

              print("âœ… Strategy cycle completed")
              return True

          # Run the cycle
          result = asyncio.run(run_single_cycle())
          sys.exit(0 if result else 1)
          PYTHON_SCRIPT

      - name: Upload Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: strategy-logs-${{ github.run_number }}
          path: |
            *.log
            strategy_config.json
          retention-days: 7

      - name: Send Notification (Success)
        if: success() && github.event.inputs.trading_mode == 'live'
        run: |
          echo "âœ… Strategy executed successfully in LIVE mode"
          # Add notification logic here (Discord, Telegram, Email, etc.)

      - name: Send Alert (Failure)
        if: failure()
        run: |
          echo "âŒ Strategy execution failed!"
          # Add alert logic here

  monitor-performance:
    name: Monitor Performance
    needs: execute-strategy
    if: success()
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Check Performance Metrics
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_KEY: ${{ secrets.SUPABASE_SERVICE_KEY }}
        run: |
          python3 << 'MONITOR'
          import os
          from supabase import create_client
          from datetime import datetime, timedelta

          # Connect to database
          supabase = create_client(
              os.environ['SUPABASE_URL'],
              os.environ['SUPABASE_SERVICE_KEY']
          )

          # Get recent performance
          one_hour_ago = (datetime.now() - timedelta(hours=1)).isoformat()

          # Query recent trades
          trades = supabase.table('trades') \
              .select('*') \
              .gte('created_at', one_hour_ago) \
              .execute()

          # Calculate metrics
          if trades.data:
              total_pnl = sum(t.get('realized_pnl', 0) for t in trades.data)
              n_trades = len(trades.data)
              win_rate = sum(1 for t in trades.data if t.get('realized_pnl', 0) > 0) / n_trades if n_trades > 0 else 0

              print(f"ðŸ“Š Last Hour Performance:")
              print(f"  Trades: {n_trades}")
              print(f"  P&L: ${total_pnl:.2f}")
              print(f"  Win Rate: {win_rate:.1%}")

              # Alert if performance is poor
              if total_pnl < -100:
                  print("âš ï¸ ALERT: Significant losses detected!")
                  exit(1)
          else:
              print("ðŸ“Š No trades in the last hour")
          MONITOR

      - name: Create Performance Report
        if: github.event.schedule
        run: |
          echo "ðŸ“ˆ Daily Performance Report - $(date)" > performance_report.txt
          echo "Strategy: StatArb v6" >> performance_report.txt
          echo "Run ID: ${{ github.run_id }}" >> performance_report.txt
          # Add more metrics as needed

  cleanup:
    name: Cleanup Old Artifacts
    runs-on: ubuntu-latest
    if: github.event.schedule  # Only run on scheduled executions

    steps:
      - name: Delete old artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const days = 7;
            const ms_per_day = 24 * 60 * 60 * 1000;
            const now = Date.now();
            const cutoff = new Date(now - days * ms_per_day).toISOString();

            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            for (const artifact of artifacts.data.artifacts) {
              if (artifact.created_at < cutoff) {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                });
                console.log(`Deleted ${artifact.name}`);
              }
            }